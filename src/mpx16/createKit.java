package mpx16;

import java.io.*;
import java.util.Arrays;

public class createKit
{
	
	private final int MIDINOTES[]={36,38,40,41,43,45,47,48,50,52,53,55,57,59,60,62};
			
//	private final int MIDINOTES[]={96,98,100,101,103,105,107,108,110,112,113,115,117,119,120,122};

//	private final int MIDINOTES[]={97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112};
	

/*
	 # #  # # #
	C D EF G A BC
	6 8 01 3 5 78
	8 0 23 5 8 01
    1 3 56 
	36 38 40 41 43 45 47 48 
	50 52 53 55 58 60 61 63

*/
	
	private final byte HEADER1[]={0x4B,0x49,0x54,0x48,0x00,(byte)0x80,0x00,0x00};
	private final byte HEADER3[]={0x04,0x6b,0x69,0x74};

	
	private final byte INTERNAL1[]={0x4B,0x49,0x54,0x49,0x01,0x00,0x00};
	private final byte EXTERNAL1[]={0x4B,0x49,0x54,0x49,0x01,0x00,0x00,0x00};

	
	private final byte EXTERNAL2[]={(byte)0xAA,0x00,0x00,0x00,0x00,0x00};
	
	private final byte INTERNAL3[]={0x00,0x00,0x00,0x64,0x01,0x00,0x00};
	
	
	private final byte EXTERNAL3[]={0x00,0x00,0x00,0x10,0x00,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
									0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x1B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
									0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
/*	
	private final byte EXTERNAL3[]={0x00,0x00,0x00,0x10,0x00,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x1B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
*/	
	private final byte INTERNAL4[]={0x00,0x0C,0x00,0x18,0x02,0x00,0x00};
		
	private final byte INTERNAL5[]={0x00,0x32,0x00,0x64,0x03,0x00,0x00};
	

	
	private final int INTERNAL2LEN=7;

	private final byte INTERNAL6[]={0x00,0x00,0x00,0x64,0x08,0x00,0x00};
	
	private final byte INTERNAL7[]={0x00,0x00,0x00,0x7F,0x09,0x00,0x00};
	

	
	private final byte INTERNAL8[]={0x00,0x00,0x00,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x03,(byte)0xE7,0x11,
									0x00,0x00,0x00,0x00,0x00,0x03,(byte)0xE7,0x12,0x00,0x03,(byte)0xE7,0x00,0x00,
									0x03,(byte)0xE7,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x64,0x14,0x00,0x00,
									0x00,0x00,0x00,0x03,(byte)0xE7,0x15,0x00,0x00,0x00,0x00,0x00,0x03,(byte)0xE7,
									0x16,0x00,0x00,0x00,0x00,0x00,0x03,(byte)0xE7,0x17,0x00,0x00,0x64,0x00,
									0x00,0x00,0x64,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x64,0x19,0x00,
									0x00,0x00,0x00,0x00,0x00,0x64,0x1A,0x00,0x00};
	
	private final byte INTERNAL9[]={0x00,0x00,0x00,0x01,0x1B,0x00,0x00};

	private final byte INTERNAL10[]={0x00,0x00,0x00,0x01,0x0E,0x00,0x00};
	private final byte INTERNAL11[]={0x00,0x00,0x00,0x10};
	
	private final byte FOOTER1[]={0x4B,0x49,0x54};
	
	
	private final byte EMPTYSAMPLE[]={ 0x4B,0x49,0x54,0x49,0x01,0x00,0x00,0x00,(byte)0xFF,(byte)0xAA,0x00,0x00,0x00,0x00,0x00,0x00,
										0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x00,0x00,0x00,0x10,0x00,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x1B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
										0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	
	private final byte PAN_CENTER=50;
	
	private final byte TRIGGER_ONE_SHOT=0;
	
	
 	
	
	private final String TESTNAME=new String("808 Kick");

	private byte workData[]=new byte[256];
	private byte outData[]=new byte[8448];
	private int outDataIdx;
	private String kitStr;
	private sampleUtils _theSampleUtil;
	
	byte inData[];
	int compData[][];
	
	public createKit(sampleUtils theSampleUtil)
	{
		_theSampleUtil=theSampleUtil;
		inData=new byte[10000];
		compData=new int[20][2000];

	}
	
	

	public int createKitFile(int kitNo,String outDir)
	{	
		Arrays.fill(workData,(byte)0);
		kitStr=Integer.toString(kitNo);
				
		
		String fileName=outDir+"KITS\\KIT"+String.format("%03d", kitNo)+".KIT";
		System.out.println("File name:"+fileName);

		writeHeader(kitNo);
		boolean external=true;
		for(int i=0;i<16;i++)
		{
			if(i<this._theSampleUtil.NumberFiles)
				external=true;
			else
				external=false;
			writeInternalBlock(i,external);
		}
			
		for(int i=0;i<16;i++)
		{
			if(i<this._theSampleUtil.NumberFiles)
				external=true;
			else
				external=false;
			writeExternalBlock(i,external);
		}
		writeFooter(kitNo);
		
		setCheckSum();
		try
		{
			FileOutputStream kitOut = new FileOutputStream(fileName);
			if(kitOut!=null)
			{
				System.out.println("writing to file");
				kitOut.write(outData);
				kitOut.close();
			}
		}
		catch (Exception outEx)
		{
			outEx.printStackTrace();
		}
		System.out.println("Complete");
				
		return 0;

	}

	private void writeFooter(int kitNo)
	{
		String footStr=String.format("%03d",kitNo);
		writeArray(FOOTER1);
		writeArray(footStr.getBytes());
		writeZeros(112);
	}
	
	private void setCheckSum()
	{
		int chkSum=0;
		for(int i=9;i<8320;i++)
		{
			chkSum+=outData[i]&0xff;
			chkSum=chkSum&0xff;
		}
		outData[8]=(byte)chkSum;
	}
	private int writeHeader(int kitNo)
	{	
//zero index
		outDataIdx=0;

//write initial header		
		writeArray(HEADER1);
//next byte is the checksum, this has to be set after we've built up the rest of the file
		writeByte((byte)0);
		writeZeros(2);
		writeByte((byte)0x10);
//more zeros
		writeZeros(48+4+7);
//kit number
		writeArray(HEADER3);
		writeArray(kitStr.getBytes());
		int bytesLeft=53-kitStr.length();
			
//padding
		writeZeros(bytesLeft);		
		
		return 0;
	}
	
	private void writeArray(byte Input[])
	{
		for(int i=0;i<Input.length;i++)
			outData[outDataIdx++]=Input[i];
	}
	
	private void writeByte(byte Byte)
	{
		outData[outDataIdx++]=Byte;
	}
	
	private void writeZeros(int len)
	{
		for(int i=0;i<len;i++)
			outData[outDataIdx++]=0;
	}
	
	private int writeInternalBlock(int blockNo,boolean isExternal)
	{
		String Name;
		byte externalFlag=0;
		int Volume=100;
		int Tune=12;
		int MIDINote=MIDINOTES[blockNo];
		int Pan=PAN_CENTER;
		int Trigger=TRIGGER_ONE_SHOT;	
		int Reverb=0;
		int MonoPoly=1;
		int Velocity=1;
		int ChokeGroup=0;
//header
		writeArray(INTERNAL1);	
		if(isExternal)
			externalFlag=1;
//internal/external flag
		writeByte(externalFlag);
			
//filler
		writeZeros(INTERNAL2LEN);
		Name=TESTNAME;
//length of name
		int nameLen=Name.length();
		writeByte((byte)nameLen);
//name
		writeArray(Name.getBytes());
//filler and some exciting bytes
		writeZeros((19-nameLen));

		writeByte((byte)0x10);
		writeZeros(1);
		writeByte((byte)0x13);
//more zeros
		writeZeros(5);
//volume
		writeByte((byte)Volume);
		
		writeArray(INTERNAL3);
//tune
		writeByte((byte)Tune);
//more filler
		writeArray(INTERNAL4);
//pan
		writeByte((byte)Pan);
//a bit more filler
		writeArray(INTERNAL5);
//reverb
		writeByte((byte)Reverb);
		writeArray(INTERNAL6);
//note
		writeByte((byte)MIDINote);
//filler
		writeArray(INTERNAL7);
//trigger
		writeByte((byte)Trigger);
//filler
		writeArray(INTERNAL8);
//mono/poly
		writeByte((byte)MonoPoly);
//filler
		writeArray(INTERNAL9);
//Velocity (on/off)
		writeByte((byte)Velocity);
//filler
		writeArray(INTERNAL10);		
//Choke Group
		writeByte((byte)ChokeGroup);
//filer
		writeArray(INTERNAL11);
//zero padding
		writeZeros(64);
		return 0;
	}

	private String formatWavName(String inName)
	{
//split at wav
		String[] splitArray = inName.split(".wav");
		String outName=splitArray[0];
//pad to 8 characters
		outName=String.format("%" + -8 + "s", outName).toUpperCase(); 
		return outName;
	}
	
	private int writeExternalBlock(int blockNo,boolean isExternal)
	{
		String Name;
		byte external=(byte)0xAA;
		int Volume=100;
		int Tune=12;
		int MIDINote=MIDINOTES[blockNo];
		int Pan=PAN_CENTER;
		int Trigger=TRIGGER_ONE_SHOT;	
		int Reverb=0;
		int MonoPoly=1;
		int Velocity=1;
		int ChokeGroup=0;
		
		
		if(isExternal)
		{
			Name=formatWavName(_theSampleUtil.FinalName[blockNo]);
//create the whole thing...
			writeArray(EXTERNAL1);
			writeByte(external);
			writeArray(EXTERNAL2);
//sample name (length first)
			writeByte((byte)Name.length());
			writeArray(Name.getBytes());
//zero filler
			int noZeros=16-Name.length();
			writeZeros(noZeros);
//write out the rest as a block
			writeArray(EXTERNAL3);
//updated firmware requires name at end of block
			noZeros=8-Name.length();
			writeArray(Name.getBytes());
			if(noZeros>0)
				writeZeros(noZeros);
		}
		else
//sound is internal, just write out standard empty sample
			writeArray(EMPTYSAMPLE);
		return 0;
	}

	public void getChkSum(String fname,int dataIdx)
	{
		readKit(fname);
		int chkSum=(inData[8]&0xff);
		System.out.println("Chk Sum 0x"+Integer.toHexString(chkSum));
//now check for stuff
		int x,y,z;
		y=0;
		int outSum;
		for(z=10;z<8448;z++)
		{
			outSum=0;
			for(x=9;x<z;x++)
			{
				outSum=outSum+inData[x]&0xff;
				outSum=outSum&0xff;	
			}
			if(outSum==chkSum)
			{
				compData[dataIdx][y++]=z;
			}
		}
		compData[dataIdx][y]=-1;
	}
	
	public void matchChkSum(int maxIdx)
	{
		int y,z;
		y=0;
		while(compData[0][y]!=-1)
		{
//get the check value				
			int chkVal=compData[0][y];
			int thisVal=-1;
//must be present in all other compares
			for(int i=1;i<maxIdx;i++)
			{
				z=0;
				thisVal=-1;
				while(compData[i][z]!=-1)
				{
					thisVal=compData[i][z];
					if(thisVal==chkVal)
						break;
					z++;
				}
				if(thisVal!=chkVal)
					break;
			}
			if(thisVal==chkVal)
				System.out.println(" MATCH - "+chkVal+ " .. "+Integer.toHexString(chkVal));
			y++;
		}
	}
	
	private void readKit(String fname)
	{
		
		System.out.println("Reading in Kit :"+fname);
			FileInputStream kitIn;
			try {
				kitIn=new FileInputStream(fname);
			} catch (FileNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
				return;
			}
			try {
				kitIn.read(inData);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			try {
				kitIn.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	
	}
	
	
	
}



